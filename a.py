"""\n.. module: hubcommander.bot_components.decorators\n    :platform: Unix\n    :copyright: (c) 2017 by Netflix Inc., see AUTHORS for more\n    :license: Apache, see LICENSE for more details.\n\n.. moduleauthor:: Mike Grima <mgrima@netflix.com>\n"""\nThis is discussion about decorator\nimport argparse\nimport shlex\n\nfrom hubcommander.bot_components.parse_functions import ParseException\nfrom hubcommander.bot_components.slack_comm import send_info, send_error\n\nARG_TYPE = ["required", "optional"]\n\n\ndef format_help_text(data, user_data, **kwargs):\n    full_help_text = "@{user}: `{command_name}`: {description}\n\n" \\n                     "```{usage}```\n\n" \\n                     "{required}" \\n                     "{optional}"\n\n    required_args = []\n    if kwargs.get("required"):\n        required_args.append("Required Arguments:")\n        for required in kwargs["required"]:\n            if type(required["name"]) is list:\n                required_args.append("\t`{name}`\t{help}".format(name=", ".join(required["name"]),\n                                                                 help=required["properties"]["help"]))\n            else:\n                required_args.append("\t`{name}`\t{help}".format(name=required["name"],\n                                                                 help=required["properties"]["help"]))\n\n        required_args = "\n".join(required_args) + "\n\n"\n\n    optional_args = ["Optional Arguments:",\n                     "\t`-h, --help`\tShow this help text."]\n    if kwargs.get("optional"):\n        for optional in kwargs["optional"]:\n            if type(optional["name"]) is list:\n                optional_args.append("\t`{name}`\t{help}".format(name=", ".join(optional["name"]),\n                                                                 help=optional["properties"]["help"]))\n            else:\n                optional_args.append("\t`{name}`\t{help}".format(name=optional["name"],\n                                                                 help=optional["properties"]["help"]))\n\n    optional_args = "\n".join(optional_args)\n\n    return full_help_text.format(\n        user=user_data["name"],\n        command_name=kwargs["name"],\n        description=kwargs["description"],\n        usage=kwargs["usage"],\n        required=required_args if required_args else "",\n        optional=optional_args if optional_args else ""\n    )\n\n\ndef perform_additional_verification(plugin_obj, args, **kwargs):\n    """\n    This will run the custom verification functions that you can set for parameters.\n\n    This will also, by default, lowercase all values that arrive. This behavior can be disabled\n    via the lowercase=False flag for the argument.\n    :param plugin_obj:\n    :param args:\n    :param kwargs:\n    :return:\n    """\n    for at in ARG_TYPE:\n        if kwargs.get(at):\n            for argument in kwargs[at]:\n                # Perform case changing logic if required (lowercase by default)\n                real_arg_name = argument["name"].replace("--", "")\n                if args.get(real_arg_name):\n                    if type(args[real_arg_name]) is str:\n                        if argument.get("uppercase", False):\n                            args[real_arg_name] = args[real_arg_name].upper()\n\n                        elif argument.get("lowercase", True):\n                            args[real_arg_name] = args[real_arg_name].lower()\n\n                        # Perform cleanups? This will remove things like the annoying macOS "smart quotes",\n                        # and the <>, {}, &lt;&gt; from the variables if `cleanup=False` not set.\n                        if argument.get("cleanup", True):\n                            args[real_arg_name] = args[real_arg_name].replace("<", "") \\n                                .replace(">", "").replace("{", "").replace("}", "") \\n                                .replace(u'\u201C', "\"").replace(u'\u201D', "\"") \\n                                .replace(u'\u2018', "\'").replace(u'\u2019', "\'") \\n                                .replace("[", "").replace("]", "") \\n                                .replace("&lt;", "").replace("&gt;", "")\n\n                    # Perform custom validation if needed:\n                    if argument.get("validation_func"):\n                        validation_kwargs = {}\n                        if argument.get("validation_func_kwargs"):\n                            validation_kwargs = argument["validation_func_kwargs"]\n\n                        args[real_arg_name] = argument["validation_func"](\n                            plugin_obj, args[real_arg_name], **validation_kwargs\n                        )\n\n    return args\n\n\ndef hubcommander_command(**kwargs):\n    def command_decorator(func):\n        def decorated_command(plugin_obj, data, user_data):\n            parser = argparse.ArgumentParser(prog=kwargs["name"],\n                                             description=kwargs["description"],\n                                             usage=kwargs["usage"])\n\n            # Dynamically add in the required and optional arguments:\n            arg_type = ["required", "optional"]\n            for at in arg_type:\n                if kwargs.get(at):\n                    for argument in kwargs[at]:\n                        # If there is a list of available values, then ensure that they are added in for argparse to\n                        # process properly. This can be done 1 of two ways:\n                        #  1.) [Not recommended] Use argparse directly by passing in a fixed list within\n                        #       `properties["choices"]`\n                        #\n                        #  2.) [Recommended] Add `choices` outside of `properties` where you can define where\n                        #      the list of values appear within the Plugin's command config. This is\n                        #      preferred, because it reflects how the command is actually configured after the plugin's\n                        #      `setup()` method is run.\n                        #\n                        #      To make use of this properly, you need to have the help text contain: "{values}"\n                        #      This will then ensure that the list of values are properly in there.\n                        ##\n                        if argument.get("choices"):\n                            # Add the dynamic choices:\n                            argument["properties"]["choices"] = plugin_obj.commands[kwargs["name"]][argument["choices"]]\n\n                            # Fix the help text:\n                            argument["properties"]["help"] = argument["properties"]["help"].format(\n                                values=", ".join(plugin_obj.commands[kwargs["name"]][argument["choices"]])\n                            )\n\n                        parser.add_argument(argument["name"], **argument["properties"])\n\n            # Remove the command from the command string:\n            split_args = shlex.split(data["text"])[1:]\n            try:\n                args = vars(parser.parse_args(split_args))\n\n            except SystemExit as _:\n                send_info(data["channel"], format_help_text(data, user_data, **kwargs), markdown=True,\n                          ephemeral_user=user_data["id"])\n                return\n\n            # Perform additional verification:\n            try:\n                args = perform_additional_verification(plugin_obj, args, **kwargs)\n            except ParseException as pe:\n                send_error(data["channel"], pe.format_proper_usage(user_data["name"]),\n                           markdown=True, ephemeral_user=user_data["id"])\n                return\n            except Exception as e:\n                send_error(data["channel"], "An exception was encountered while running validation for the input. "\n                                            "The exception details are: `{}`".format(str(e)),\n                           markdown=True)\n                return\n\n            # Run the next function:\n            data["command_name"] = kwargs["name"]\n            return func(plugin_obj, data, user_data, **args)\n\n        return decorated_command\n\n    return command_decorator\n\n\ndef auth(**kwargs):\n    def command_decorator(func):\n        def decorated_command(command_plugin, data, user_data, *args, **kwargs):\n            print ("auth", args, kwargs)\n            # Perform authentication:\n            if command_plugin.commands[data["command_name"]].get("auth"):\n                \n                if not command_plugin.commands[data["command_name"]]["auth"]["plugin"].authenticate(\n                        data, user_data, *args, **command_plugin.commands[data["command_name"]]["auth"]["kwargs"]):\n                    return\n\n            print (func)\n            # Run the next function:\n            return func(command_plugin, data, user_data, *args, **kwargs)\n\n        return decorated_command\n\n    return command_decorator\n